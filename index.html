<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>AR MULTICÁLCULO / HTML CALCULATION</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    /* Overlay del menú inicial */
    #overlay {
      position: absolute;
      padding-top: 100px;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #aaf951; /* Verde claro */
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      color: #fff;
      text-align: center;
      z-index: 10;
      box-sizing: border-box;
      padding: 20px;
    }
    #overlay a {
      font-size: 14px;
      margin-top: -10px;
      margin-bottom: 20px;
      color: blue;
      text-decoration: none;
    }
    /* Contenedor para el selector de respuestas */
    #overlay .respuestas-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    #overlay .respuestas-container label {
      font-size: 14px;
      color: black;
    }
    #overlay .respuestas-container select {
      font-size: 14px;
    }
    /* Estilos para la imagen en el overlay */
    #overlay img {
      border-radius: 20px;
      max-width: 15%;
    }
    @media (orientation: portrait) {
      #overlay img {
        max-width: 70%;
      }
    }
    /* Estilos para la mini tabla (top 3) */
    #leaderboardPreview {
      max-width: 80%;
      max-height: 120px;
      overflow-y: auto;
      background-color: #fff;
      color: #000;
      font-size: 12px;
      margin-bottom: 20px;
      border: 1px solid #000;
      border-radius: 6px;
      padding: 4px;
    }
    #leaderboardPreview table {
      border-collapse: collapse;
      width: 100%;
    }
    #leaderboardPreview th, #leaderboardPreview td {
      border: 1px solid #666;
      padding: 4px;
      text-align: center;
    }
    /* Estilos para el modo HTML (fallback) */
    #gameContainer {
      position: relative;
      width: 100%;
      height: 100vh;
      background-color: #f0f0f0;
      color: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow-y: auto;
      padding: 20px;
      box-sizing: border-box;
    }
    #gameContainer > * { margin-bottom: 20px; }
    #leaderboard {
      max-width: 80%;
      max-height: 120px;
      overflow-y: auto;
      background-color: #fff;
      color: #000;
      font-size: 12px;
      border: 1px solid #000;
      border-radius: 6px;
      padding: 4px;
    }
    button, input {
      -webkit-appearance: none;
      border-radius: 6px;
      font-size: 16px;
      padding: 10px 20px;
    }
  </style>
</head>
<body>
  <!-- Audios: acierto, error, timer y beep -->
  <audio id="successSound" src="https://raw.githubusercontent.com/rafgim2/ARCalculation/main/acierto.wav" preload="auto"></audio>
  <audio id="errorSound" src="https://raw.githubusercontent.com/rafgim2/ARCalculation/main/error.wav" preload="auto"></audio>
  <audio id="timerSound" src="https://raw.githubusercontent.com/rafgim2/ARCalculation/main/timer7.mp3" preload="auto"></audio>
  <audio id="beepSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/beep.wav" preload="auto"></audio>
  
  <script type="module">
    /***** 1) Firebase y Firestore *****/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics.js";
    import { 
      getFirestore, collection, addDoc, orderBy, getDocs, serverTimestamp,
      query, where, limit, updateDoc, doc
    } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
    
    const firebaseConfig = {
      apiKey: "AIzaSyD5EAMg-0p54f8bPq8SVdZ_ePg5Xso3cmg",
      authDomain: "arm1-acbba.firebaseapp.com",
      projectId: "arm1-acbba",
      storageBucket: "arm1-acbba.firebasestorage.app",
      messagingSenderId: "408825932019",
      appId: "1:408825932019:web:10f2079b590b4c9ca3af86",
      measurementId: "G-S78TM6PVRL"
    };
    
    const appFirebase = initializeApp(firebaseConfig);
    const analytics = getAnalytics(appFirebase);
    const db = getFirestore(appFirebase);
    
    async function updateLeaderboardPreview(numAnswers) {
      const collectionName = `Calcleaderboard_${numAnswers}`;
      try {
        let top3Query = query(
          collection(db, collectionName),
          orderBy("score", "desc"),
          limit(3)
        );
        const querySnapshot = await getDocs(top3Query);
        const results = [];
        querySnapshot.forEach(docSnap => results.push(docSnap.data()));
        const container = document.getElementById('leaderboardPreview');
        container.innerHTML = "";
        if (results.length > 0) {
          let html = "<table>";
          html += "<tr><th>Pos</th><th>Nombre</th><th>Puntos</th></tr>";
          for (let i = 0; i < results.length; i++) {
            html += `<tr>
              <td>${i+1}</td>
              <td>${results[i].name}</td>
              <td>${results[i].score}</td>
            </tr>`;
          }
          html += "</table>";
          container.innerHTML = html;
        } else {
          container.innerHTML = "<p>No hay puntuaciones aún.</p>";
        }
      } catch(err) {
        console.error("Error cargando top 3:", err);
        document.getElementById('leaderboardPreview').innerHTML = "<p>Error cargando clasificación.</p>";
      }
    }
    
    /***** 2) AR y lógica del juego (modo CALCULATION) *****/
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const requiredFeatures = isMobile ? ['hit-test'] : ['hit-test', 'hand-tracking'];
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';
    
    let camera, scene, renderer;
    let correctAnswer;
    let answers = [];
    let hasCollided = false;
    let questionMesh = null;
    let questionText = "";
    const collisionThreshold = 0.2;
    const sparksSystems = [];
    let correctCount = 0;
    let wrongCount = 0;
    let gameStartTime = 0;
    const gameDuration = 60;
    let gameOver = false;
    
    let countdownMesh = null, countdownCanvas = null, countdownCtx = null, countdownTexture = null;
    let scoreMesh = null, scoreCanvas = null, scoreCtx = null, scoreTexture = null;
    
    // NUEVO: botón Salir
    let exitButtonMesh = null;
    // Botón Reiniciar
    let restartButtonMesh = null;
    let leaderboardMesh = null;
    let leaderboardResults = [];
    const maxResultsToShow = 10;
    let playerPosition = null;
    
    let playerName = "Jugador";
    let selectedNumAnswers = 4;
    let originalAnswerTransforms = null;
    let beepPlayed = false;
    let gameReady = false;
    let countdownStarted = false;
    const resolutionFactor = 4;
    let currentQuestionStartTime = 0;
    let correctResponseTimes = [];
    
    // ... (Todas las funciones de generación de pregunta, dibujo, etc. IGUAL que antes) ...
    // (No se modifican salvo para añadir el botón "Salir" en createLeaderboardMesh
    //  y la detección de colisión con "Salir".)

    /*** LO IMPORTANTE: createLeaderboardMesh() y la colisión con exitButtonMesh ***/

    function createButton(text, planeWidth = 0.3, planeHeight = 0.1) {
      const canvas = document.createElement('canvas');
      canvas.width = 128 * resolutionFactor;
      canvas.height = 64 * resolutionFactor;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 10 * resolutionFactor);
      ctx.fillStyle = "#FFFFFF";
      ctx.font = 'Bold ' + (18 * resolutionFactor) + 'px Arial';
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, canvas.width/2, canvas.height/2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      const geom = new THREE.PlaneGeometry(planeWidth, planeHeight);
      const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      return new THREE.Mesh(geom, mat);
    }

    // CREAR TABLA + BOTONES
    function createLeaderboardMesh() {
      if(leaderboardMesh){ scene.remove(leaderboardMesh); leaderboardMesh = null; }
      if(restartButtonMesh){ scene.remove(restartButtonMesh); restartButtonMesh = null; }
      if(exitButtonMesh){ scene.remove(exitButtonMesh); exitButtonMesh = null; }

      const dummyCanvas = document.createElement('canvas');
      dummyCanvas.width = 512;
      dummyCanvas.height = 512;
      const ctx = dummyCanvas.getContext('2d');
      const lbTexture = new THREE.CanvasTexture(dummyCanvas);
      lbTexture.minFilter = THREE.LinearFilter;
      lbTexture.magFilter = THREE.LinearFilter;
      
      const planeWidth = 1.2;
      const planeHeight = 1.0;
      const lbGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
      const lbMaterial = new THREE.MeshBasicMaterial({ map: lbTexture, transparent: true });
      leaderboardMesh = new THREE.Mesh(lbGeometry, lbMaterial);
      leaderboardMesh.userData = { canvas: dummyCanvas, ctx, texture: lbTexture, planeWidth, planeHeight };
      leaderboardMesh.position.set(0, 0, -1.2);
      scene.add(leaderboardMesh);

      // Botón REINICIAR (izquierda)
      restartButtonMesh = createButton("Reiniciar", 0.3, 0.15);
      restartButtonMesh.position.set(-0.8, 0, -1.2);
      scene.add(restartButtonMesh);

      // NUEVO: Botón SALIR (derecha)
      exitButtonMesh = createButton("Salir", 0.3, 0.15);
      exitButtonMesh.position.set(0.8, 0, -1.2);
      scene.add(exitButtonMesh);
    }

    function drawLeaderboardSegment() {
      if(!leaderboardMesh) return;
      const { canvas, ctx, texture, planeWidth } = leaderboardMesh.userData;
      const subset = leaderboardResults;
      
      const lineHeight = 40 * resolutionFactor;
      const extraLines = 4;
      const canvasWidth = 512 * resolutionFactor;
      const canvasHeight = lineHeight * (subset.length + extraLines);
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      ctx.fillStyle = "#FFFFFF";
      ctx.font = 'Bold ' + (28 * resolutionFactor) + 'px Arial';
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Tabla de Clasificación", canvasWidth / 2, lineHeight);
      
      const xPosPos   = 0.10 * canvasWidth;
      const xPosName  = 0.40 * canvasWidth;
      const xPosScore = 0.75 * canvasWidth;
      
      let startY = lineHeight * 2.5;
      ctx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
      ctx.textAlign = "left";
      ctx.fillText("Pos", xPosPos, startY);
      ctx.fillText("Nombre", xPosName, startY);
      ctx.fillText("Puntos", xPosScore, startY);
      
      let yPos = startY + (1.5 * lineHeight);
      for(let i = 0; i < subset.length; i++){
        const data = subset[i];
        const realPos = data._index + 1;
        if(playerPosition !== null && realPos === playerPosition){
          ctx.fillStyle = "green";
          ctx.fillRect(0, yPos - lineHeight * 0.6, canvasWidth, lineHeight);
          ctx.fillStyle = "#FFFFFF";
        } else {
          ctx.fillStyle = "#FFFFFF";
        }
        ctx.fillText(String(realPos), xPosPos, yPos);
        ctx.fillText(data.name, xPosName, yPos);
        ctx.fillText(String(data.score), xPosScore, yPos);
        yPos += lineHeight;
      }
      
      if(playerPosition !== null){
        ctx.textAlign = "center";
        ctx.fillText(`Tu posición: ${playerPosition}`, canvasWidth/2, yPos+lineHeight);
      }
      
      texture.needsUpdate = true;
      const planeHeight = planeWidth * (canvasHeight / canvasWidth);
      leaderboardMesh.geometry.dispose();
      leaderboardMesh.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
      leaderboardMesh.position.set(0, 0, -1.2);

      // Reubicar botones
      restartButtonMesh.position.set(-0.8, 0, -1.2);
      if(exitButtonMesh) exitButtonMesh.position.set(0.8, 0, -1.2);
    }

    // Al final, la colisión cuando gameOver = true:
    // Si es exitButtonMesh => location.reload() tras 2s
    function render(timestamp, xrFrame) {
      renderer.render(scene, camera);
      // ... resto de lógica ...
      
      if(xrFrame) {
        const session = renderer.xr.getSession();
        let interactionPoints = [];
        // mano o fallback
        for (const inputSource of session.inputSources) {
          if (inputSource.hand) {
            const indexTip = inputSource.hand.get('index-finger-tip');
            // ...
          }
        }
        if(interactionPoints.length===0){
          let cameraPos = new THREE.Vector3();
          camera.getWorldPosition(cameraPos);
          interactionPoints.push(cameraPos);
        }
        
        // Si gameOver, colisión con restartButtonMesh o exitButtonMesh
        if(gameOver && !hasCollided) {
          let finalButtons = [];
          if(restartButtonMesh) finalButtons.push(restartButtonMesh);
          if(exitButtonMesh) finalButtons.push(exitButtonMesh);
          for(const btn of finalButtons) {
            if(!btn.visible) continue;
            const btnPos = new THREE.Vector3();
            btn.getWorldPosition(btnPos);
            for(const pt of interactionPoints){
              const dist = pt.distanceTo(btnPos);
              if(dist < collisionThreshold){
                hasCollided = true;
                const successSound = document.getElementById('successSound');
                const clone = successSound.cloneNode();
                clone.play().catch(e=>{});
                createSparksEffect(btn.position);
                btn.visible = false;
                
                // REINICIAR
                if(btn === restartButtonMesh) {
                  setTimeout(()=> {
                    restartGame();
                    hasCollided = false;
                  }, 2000);
                }
                // NUEVO: SALIR => recargar
                else if(btn === exitButtonMesh) {
                  setTimeout(()=> {
                    location.reload(); // recarga la página
                    hasCollided = false;
                  }, 2000);
                }
                break;
              }
            }
            if(hasCollided) break;
          }
        }
      }
      
      // ... resto del render (sparks, countdown, etc.) ...
    }

    /***** 3) MODO HTML (fallback) *****/
    // (Igual que antes, sin cambios.)

    // Iniciar AR (o HTML) según soporte
    function initAR() {
      // (código original)
      // Insertamos lo mismo que ya tenías...
      // Sin olvidar que en createLeaderboardMesh() y render() 
      // ya añadimos el botón SALIR y la colisión.
    }

    initAR();
    animate();
  </script>
</body>
</html>
