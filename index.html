<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>AR Capitals Game / HTML Capitals Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <style>
      /* Estilos generales (compartidos para AR y HTML) */
      body {
        margin: 0;
        font-family: sans-serif;
        overflow-y: auto;
      }
      /* Estilos del overlay inicial */
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        min-height: 100vh;
        background-color: #fffa9c;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        text-align: center;
        z-index: 10;
        overflow-y: auto;
        box-sizing: border-box;
        padding: 20px;
      }
      #overlay a {
        font-size: 14px;
        margin-top: 10px;
        margin-bottom: 20px;
        color: blue;
        text-decoration: none;
      }
      #overlay .respuestas-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 20px;
      }
      #overlay .respuestas-container label {
        font-size: 14px;
        color: black;
      }
      #overlay .respuestas-container select {
        font-size: 14px;
      }
      #overlay img {
        border-radius: 20px;
        max-width: 15%;
        margin-top: 50px;
        margin-bottom: 10px;
      }
      @media (orientation: portrait) {
        #overlay img {
          max-width: 70%;
        }
      }
      /* Leaderboard preview en el overlay */
      #leaderboardPreview {
        max-width: 80%;
        max-height: 120px;
        overflow-y: auto;
        background-color: #fff;
        color: #000;
        font-size: 12px;
        margin-bottom: 20px;
        border: 1px solid #000;
        border-radius: 6px;
        padding: 4px;
      }
      #leaderboardPreview table {
        border-collapse: collapse;
        width: 100%;
      }
      #leaderboardPreview th, #leaderboardPreview td {
        border: 1px solid #666;
        padding: 4px;
        text-align: center;
      }
      /* Estilos del contenedor HTML para el modo no AR */
      #gameContainer {
        position: relative;
        width: 100%;
        min-height: 100vh;
        background-color: #f0f0f0;
        color: #000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        box-sizing: border-box;
      }
      #gameContainer div, #gameContainer button {
        margin-bottom: 20px;
      }
      #gameContainer button {
        font-size: 24px;
        padding: 10px 20px;
      }
      #gameContainer table {
        width: 100%;
        border-collapse: collapse;
      }
      #gameContainer th, #gameContainer td {
        border: 1px solid #666;
        padding: 4px;
        text-align: center;
      }
      button, input {
        -webkit-appearance: none;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <!-- Audios -->
    <audio id="successSound" src="https://raw.githubusercontent.com/rafgim2/ARCapitals/main/acierto.wav" preload="auto"></audio>
    <audio id="errorSound" src="https://raw.githubusercontent.com/rafgim2/ARCapitals/main/error.wav" preload="auto"></audio>
    <audio id="timerSound" src="https://raw.githubusercontent.com/rafgim2/ARCapitals/main/timer7.mp3" preload="auto"></audio>
    <!-- Nota: actualmente, beepSound usa el mismo archivo que errorSound -->
    <audio id="beepSound" src="https://raw.githubusercontent.com/rafgim2/ARCapitals/main/error.wav" preload="auto"></audio>

    <script type="module">
      /***** 1) Firebase y Firestore *****/
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics.js";
      import { 
        getFirestore, collection, addDoc, orderBy, getDocs, serverTimestamp,
        query, where, limit, updateDoc, doc
      } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyD5EAMg-0p54f8bPq8SVdZ_ePg5Xso3cmg",
        authDomain: "arm1-acbba.firebaseapp.com",
        projectId: "arm1-acbba",
        storageBucket: "arm1-acbba.firebasestorage.app",
        messagingSenderId: "408825932019",
        appId: "1:408825932019:web:10f2079b590b4c9ca3af86",
        measurementId: "G-S78TM6PVRL"
      };

      const appFirebase = initializeApp(firebaseConfig);
      const analytics = getAnalytics(appFirebase);
      const db = getFirestore(appFirebase);

      /***** 2) Función para actualizar el leaderboard preview en el overlay *****/
      async function updateLeaderboardPreview(numAnswers) {
        const collectionName = `Capleaderboard_${numAnswers}`;
        try {
          let top3Query = query(
            collection(db, collectionName),
            orderBy("score", "desc"),
            limit(3)
          );
          const querySnapshot = await getDocs(top3Query);
          const results = [];
          querySnapshot.forEach((docSnap) => {
            results.push(docSnap.data());
          });

          const container = document.getElementById('leaderboardPreview');
          container.innerHTML = "";
          if (results.length > 0) {
            let html = "<table>";
            html += "<tr><th>Pos</th><th>Nombre</th><th>Puntos</th></tr>";
            for (let i = 0; i < results.length; i++) {
              html += `<tr>
                <td>${i+1}</td>
                <td>${results[i].name}</td>
                <td>${results[i].score}</td>
              </tr>`;
            }
            html += "</table>";
            container.innerHTML = html;
          } else {
            container.innerHTML = "<p>No hay puntuaciones aún.</p>";
          }
        } catch (err) {
          console.error("Error cargando top 3:", err);
          document.getElementById('leaderboardPreview').innerHTML =
            "<p>Error cargando clasificación.</p>";
        }
      }

      /***** 3) Código AR (Capitals) *****/
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';

      // Variables globales del juego AR
      let camera, scene, renderer;
      let questionMesh = null;
      let answers = [];
      let correctAnswer = "";
      let hasCollided = false;
      let gameOver = false;
      let correctCount = 0;
      let wrongCount = 0;
      let questionText = "";
      let selectedNumAnswers = 4;
      const gameDuration = 60; // segundos
      const collisionThreshold = 0.2;
      const resolutionFactor = 4;

      // Variables para HUD y countdown
      let countdownMesh, scoreMesh;
      let beepPlayed = false;
      let gameReady = false;
      let countdownStarted = false;
      
      // Variables para efectos y tiempos
      let initialCameraPos = new THREE.Vector3();
      let initialCameraDir = new THREE.Vector3();
      let sparkTexture = null;
      const sparksSystems = [];
      let currentQuestionStartTime = 0;
      let correctResponseTimes = [];
      let leaderboardResults = [];
      let playerPosition = null;
      // NUEVO: añadimos exitButtonMesh además del restartButtonMesh
      let leaderboardMesh = null, restartButtonMesh = null, exitButtonMesh = null;

      let gameStartTime = 0;
      let playerName = "";

      function drawRoundedRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
        ctx.fill();
      }

      function createCanvasPlane(canvas, ctx, width, height) {
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(width, height);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData = { canvas, ctx, texture };
        return mesh;
      }

      function createButton(text, planeWidth = 0.3, planeHeight = 0.1) {
        const canvas = document.createElement('canvas');
        canvas.width = 256 * resolutionFactor;
        canvas.height = 64 * resolutionFactor;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 10 * resolutionFactor);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (18 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        return new THREE.Mesh(geometry, material);
      }

      // Función para detectar toques en AR (para móviles)
      function onTouchStartAR(event) {
        if (!/Mobi|Android/i.test(navigator.userAgent)) return;
        const touch = event.touches[0];
        const x = (touch.clientX / window.innerWidth) * 2 - 1;
        const y = -(touch.clientY / window.innerHeight) * 2 + 1;
        const mouseVector = new THREE.Vector2(x, y);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouseVector, camera);
        let objectsToIntersect = [];
        if (!gameOver) {
          objectsToIntersect = answers;
        } else {
          // En estado final, consideramos reiniciar + salir
          objectsToIntersect = [];
          if (restartButtonMesh) objectsToIntersect.push(restartButtonMesh);
          if (exitButtonMesh) objectsToIntersect.push(exitButtonMesh);
        }
        const intersects = raycaster.intersectObjects(objectsToIntersect);
        if (intersects.length > 0 && !hasCollided) {
          const objHit = intersects[0].object;
          hasCollided = true;
          if (!gameOver) {
            if (objHit.userData.answer === correctAnswer) {
              let responseTime = performance.now() - currentQuestionStartTime;
              correctResponseTimes.push(responseTime);
              correctCount++;
              playSound('successSound');
              createSparksEffect(objHit.position);
              if (questionMesh) questionMesh.visible = false;
              answers.forEach(a => a.visible = false);
              setTimeout(() => {
                if (!gameOver) {
                  generateQuestion();
                  if (questionMesh) questionMesh.visible = true;
                  answers.forEach(a => a.visible = true);
                }
                hasCollided = false;
              }, 1000);
            } else {
              wrongCount++;
              playSound('errorSound');
              answers.forEach(a => a.material.color.set(0xff0000));
              setTimeout(() => {
                answers.forEach(a => a.material.color.set(0xffffff));
                hasCollided = false;
              }, 500);
            }
          } else {
            // Colisión con los botones finales
            if (objHit === restartButtonMesh) {
              playSound('successSound');
              createSparksEffect(objHit.position);
              objHit.visible = false;
              setTimeout(() => {
                restartGame();
                hasCollided = false;
              }, 1000);

            } else if (objHit === exitButtonMesh) {
              // NUEVO: Botón SALIR => recarga la página a los 2s
              playSound('successSound');
              createSparksEffect(objHit.position);
              objHit.visible = false;
              setTimeout(() => {
                location.reload(); // recarga la página
                hasCollided = false;
              }, 2000);
            }
          }
        }
      }
      window.addEventListener('touchstart', onTouchStartAR, false);

      function playSound(id) {
        const el = document.getElementById(id);
        if (el) {
          const clone = el.cloneNode();
          clone.play().catch(e => {});
        }
      }

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);

        window.addEventListener('resize', onWindowResize);

        // Overlay inicial
        const overlay = document.createElement('div');
        overlay.id = 'overlay';
        overlay.innerHTML = `
          <img src="ARCapitals2.jpeg" alt="ARCapitals" style="margin-bottom:0px; margin-top:0px;">
          <a href="https://www.youtube.com/@rafgim" target="_blank">© By Rafael Gimeno</a>
          <div class="respuestas-container">
            <label for="numAnswers">Respuestas:</label>
            <select id="numAnswers">
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
              <option value="8">8</option>
              <option value="9">9</option>
              <option value="10">10</option>
            </select>
          </div>
          <div id="leaderboardPreview"></div>
          <input type="text" id="playerName" placeholder="Ingresa tu nombre" style="padding:10px; font-size:16px; margin-bottom:20px;" maxlength="10">
        `;

        // Botón AR (igual que antes)
        const arButton = ARButton.createButton(renderer, { 
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['hand-tracking']
        });
        // Esperar un poco para que Three.js inyecte sus estilos
setTimeout(() => {
  // Elimina anchos y transform heredados
  arButton.style.removeProperty("width");
  arButton.style.removeProperty("left");
  arButton.style.removeProperty("transform");

  // Posicionar absolutamente a 615px de la parte superior
  arButton.style.position = 'absolute';
  arButton.style.top = '615px';

  // Centrar horizontalmente
  arButton.style.left = '50%';
  // El -50% se refiere a la mitad de su propio ancho
  arButton.style.transform = 'translateX(-50%)';

  // Dejar que el ancho se ajuste al texto; 
  // si lo prefieres fijo, pon arButton.style.width = "200px";
  arButton.style.width = 'auto';
  arButton.style.minWidth = '200px';

  // Inline-block para ajustarse al contenido
  arButton.style.display = 'inline-block';
  arButton.style.whiteSpace = 'nowrap';

  // Opcional: alto fijo, color, etc.
  arButton.style.height = '50px';
  arButton.style.fontSize = '16px';
  arButton.style.backgroundColor = 'green';
  arButton.style.color = 'white';

  // Cambiar el texto final
  arButton.textContent = "INICIAR VERSIÓN AR";
}, 100);

// Finalmente, agregarlo al overlay
overlay.appendChild(arButton);

        // BOTÓN ADICIONAL: Iniciar versión HTML
        const htmlButton = document.createElement('button');
        htmlButton.innerText = "Iniciar versión HTML";
        htmlButton.style.fontSize = '16px';
        htmlButton.style.padding = '10px 20px';
        htmlButton.style.marginTop = '0px';
        htmlButton.onclick = () => {
          selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
          playerName = document.getElementById('playerName').value || "Jugador";
          overlay.remove();
          if (renderer.xr && renderer.xr.getSession()) {
            renderer.xr.getSession().end().catch(e => console.error(e));
          }
          if (renderer && renderer.domElement && renderer.domElement.parentNode) {
            renderer.domElement.parentNode.removeChild(renderer.domElement);
          }
          initHTML();
        };
        overlay.appendChild(htmlButton);

        document.body.appendChild(overlay);

        const selectAnswers = document.getElementById('numAnswers');
        selectAnswers.addEventListener('change', () => {
          const num = parseInt(selectAnswers.value) || 4;
          updateLeaderboardPreview(num);
        });
        updateLeaderboardPreview(4);

        renderer.xr.addEventListener('sessionstart', () => {
          selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
          playerName = document.getElementById('playerName').value || "Jugador";
          camera.getWorldPosition(initialCameraPos);
          camera.getWorldDirection(initialCameraDir);
          initialCameraDir.normalize();
          createAnswerObjects(selectedNumAnswers, true);
          overlay.remove();
          generateQuestion();
          createScoreDisplay();
          gameReady = true;
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function createAnswerObjects(numAnswers, initialCreation) {
        if (initialCreation) {
          const radius = 0.8;
          const angleStart = -Math.PI/4;
          const angleEnd = Math.PI/4;
          for (let i = 0; i < numAnswers; i++) {
            const canvas = document.createElement('canvas');
            canvas.width = 256 * resolutionFactor;
            canvas.height = 256 * resolutionFactor;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#007BFF";
            drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
            ctx.fillStyle = "#FFFFFF";
            ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("...", canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
            const geometry = new THREE.PlaneGeometry(0.15, 0.15);
            const mesh = new THREE.Mesh(geometry, material);
            const angle = angleStart + (angleEnd - angleStart) * (i / (numAnswers - 1));
            mesh.position.set(
              radius * Math.sin(angle),
              0,
              -radius * Math.cos(angle)
            );
            mesh.lookAt(initialCameraPos);
            mesh.userData.answer = "";
            answers.push(mesh);
            scene.add(mesh);
          }
        } else {
          const wrongSet = new Set();
          while (wrongSet.size < (selectedNumAnswers - 1)) {
            const rnd = Math.floor(Math.random() * countries.length);
            const cand = countries[rnd].capital;
            if (cand !== correctAnswer) {
              wrongSet.add(cand);
            }
          }
          const array = [correctAnswer, ...wrongSet];
          array.sort(() => Math.random() - 0.5);
          for (let i = 0; i < selectedNumAnswers; i++) {
            updateAnswerPanel(answers[i], array[i]);
          }
          const radius = 0.8;
          const uniformGap = 0.1;
          let alphas = [];
          for (let i = 0; i < selectedNumAnswers; i++) {
            let panelWidth = answers[i].userData.panelWidth;
            let alpha = Math.atan((panelWidth / 2) / radius);
            alphas.push(alpha);
          }
          let totalSpan = alphas[0] + alphas[selectedNumAnswers - 1] + uniformGap * (selectedNumAnswers - 1);
          for (let i = 0; i < selectedNumAnswers - 1; i++) {
            totalSpan += alphas[i] + alphas[i + 1];
          }
          let theta = [];
          theta[0] = -totalSpan / 2 + alphas[0];
          for (let i = 0; i < selectedNumAnswers - 1; i++) {
            theta[i + 1] = theta[i] + alphas[i] + uniformGap + alphas[i + 1];
          }
          for (let i = 0; i < selectedNumAnswers; i++) {
            answers[i].position.set(
              radius * Math.sin(theta[i]),
              answers[i].position.y,
              -radius * Math.cos(theta[i])
            );
            answers[i].lookAt(initialCameraPos);
          }
        }
      }

      function updateAnswerPanel(mesh, value) {
        const tmpCanvas = document.createElement('canvas');
        const tmpCtx = tmpCanvas.getContext('2d');
        const fontSize = 75 * resolutionFactor;
        tmpCtx.font = 'Bold ' + fontSize + 'px Arial';
        const metrics = tmpCtx.measureText(value);
        const padding = 40 * resolutionFactor;
        const canvasWidth = metrics.width + padding;
        const canvasHeight = fontSize + padding;

        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');
        ctx.font = 'Bold ' + fontSize + 'px Arial';
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(value, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const scaleFactor = 0.15 / (256 * resolutionFactor);
        const newWidth = canvas.width * scaleFactor;
        const newHeight = canvas.height * scaleFactor;

        mesh.material.map = texture;
        mesh.material.needsUpdate = true;
        mesh.geometry.dispose();
        mesh.geometry = new THREE.PlaneGeometry(newWidth, newHeight);
        mesh.userData.panelWidth = newWidth;
        mesh.userData.answer = value;
      }

      function updateQuestionPanel() {
        const tmpCanvas = document.createElement('canvas');
        const tmpCtx = tmpCanvas.getContext('2d');
        const fontSize = 48 * resolutionFactor;
        tmpCtx.font = 'Bold ' + fontSize + 'px Arial';
        const metrics = tmpCtx.measureText(questionText);
        const padding = 40 * resolutionFactor;
        const canvasWidth = metrics.width + padding;
        const canvasHeight = 128 * resolutionFactor;

        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');
        ctx.font = 'Bold ' + fontSize + 'px Arial';
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(questionText, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const scaleX = 0.6 / (512 * resolutionFactor);
        const scaleY = 0.15 / (128 * resolutionFactor);
        const newWidth = canvas.width * scaleX;
        const newHeight = canvas.height * scaleY;

        if (questionMesh) scene.remove(questionMesh);
        const geometry = new THREE.PlaneGeometry(newWidth, newHeight);
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
        questionMesh = new THREE.Mesh(geometry, material);
        questionMesh.position.set(0, 0.3, -0.8);
        scene.add(questionMesh);
      }

      const countries = [
        { country: "Afganistán", capital: "Kabul" },
        { country: "Albania", capital: "Tirana" },
        { country: "Argelia", capital: "Argel" },
        { country: "Andorra", capital: "Andorra la Vieja" },
        { country: "Angola", capital: "Luanda" },
        { country: "Antigua y Barbuda", capital: "Saint John's" },
        { country: "Argentina", capital: "Buenos Aires" },
        { country: "Armenia", capital: "Ereván" },
        { country: "Australia", capital: "Camberra" },
        { country: "Austria", capital: "Viena" },
        { country: "Azerbaiyán", capital: "Bakú" },
        { country: "Bahamas", capital: "Nasáu" },
        { country: "Baréin", capital: "Manama" },
        { country: "Bangladés", capital: "Daca" },
        { country: "Barbados", capital: "Bridgetown" },
        { country: "Bielorrusia", capital: "Minsk" },
        { country: "Bélgica", capital: "Bruselas" },
        { country: "Belice", capital: "Belmopán" },
        { country: "Benín", capital: "Porto Novo" },
        { country: "Bután", capital: "Thimphu" },
        { country: "Bolivia", capital: "Sucre" },
        { country: "Bosnia y Herzegovina", capital: "Sarajevo" },
        { country: "Botsuana", capital: "Gaborone" },
        { country: "Brasil", capital: "Brasilia" },
        { country: "Brunéi", capital: "Bandar Seri Begawan" },
        { country: "Bulgaria", capital: "Sofía" },
        { country: "Burkina Faso", capital: "Uagadugú" },
        { country: "Burundi", capital: "Gitega" },
        { country: "Cabo Verde", capital: "Praia" },
        { country: "Camboya", capital: "Nom Pen" },
        { country: "Camerún", capital: "Yaundé" },
        { country: "Canadá", capital: "Ottawa" },
        { country: "República Centroafricana", capital: "Bangui" },
        { country: "Chad", capital: "Yamena" },
        { country: "Chile", capital: "Santiago" },
        { country: "China", capital: "Pekín" },
        { country: "Colombia", capital: "Bogotá" },
        { country: "Comoras", capital: "Moroni" },
        { country: "Congo (Brazzaville)", capital: "Brazzaville" },
        { country: "Congo (Kinshasa)", capital: "Kinsasa" },
        { country: "Costa Rica", capital: "San José" },
        { country: "Costa de Marfil", capital: "Yamusukro" },
        { country: "Croacia", capital: "Zagreb" },
        { country: "Cuba", capital: "La Habana" },
        { country: "Chipre", capital: "Nicosia" },
        { country: "República Checa", capital: "Praga" },
        { country: "Dinamarca", capital: "Copenhague" },
        { country: "Yibuti", capital: "Yibuti" },
        { country: "Dominica", capital: "Roseau" },
        { country: "República Dominicana", capital: "Santo Domingo" },
        { country: "Ecuador", capital: "Quito" },
        { country: "Egipto", capital: "El Cairo" },
        { country: "El Salvador", capital: "San Salvador" },
        { country: "Guinea Ecuatorial", capital: "Malabo" },
        { country: "Eritrea", capital: "Asmara" },
        { country: "Estonia", capital: "Tallin" },
        { country: "Esuatini", capital: "Mbabane" },
        { country: "Etiopía", capital: "Adís Abeba" },
        { country: "Fiyi", capital: "Suva" },
        { country: "Finlandia", capital: "Helsinki" },
        { country: "Francia", capital: "París" },
        { country: "Gabón", capital: "Libreville" },
        { country: "Gambia", capital: "Banjul" },
        { country: "Georgia", capital: "Tiflis" },
        { country: "Alemania", capital: "Berlín" },
        { country: "Ghana", capital: "Acra" },
        { country: "Grecia", capital: "Atenas" },
        { country: "Granada", capital: "Saint George's" },
        { country: "Guatemala", capital: "Ciudad de Guatemala" },
        { country: "Guinea", capital: "Conakri" },
        { country: "Guinea-Bisáu", capital: "Bisáu" },
        { country: "Guyana", capital: "Georgetown" },
        { country: "Haití", capital: "Puerto Príncipe" },
        { country: "Honduras", capital: "Tegucigalpa" },
        { country: "Hungría", capital: "Budapest" },
        { country: "Islandia", capital: "Reikiavik" },
        { country: "India", capital: "Nueva Delhi" },
        { country: "Indonesia", capital: "Yakarta" },
        { country: "Irán", capital: "Teherán" },
        { country: "Irak", capital: "Bagdad" },
        { country: "Irlanda", capital: "Dublín" },
        { country: "Israel", capital: "Jerusalén" },
        { country: "Italia", capital: "Roma" },
        { country: "Jamaica", capital: "Kingston" },
        { country: "Japón", capital: "Tokio" },
        { country: "Jordania", capital: "Amán" },
        { country: "Kazajistán", capital: "Astaná" },
        { country: "Kenia", capital: "Nairobi" },
        { country: "Kiribati", capital: "Tarawa" },
        { country: "Corea del Norte", capital: "Pyongyang" },
        { country: "Corea del Sur", capital: "Seúl" },
        { country: "Kosovo", capital: "Pristina" },
        { country: "Kuwait", capital: "Kuwait" },
        { country: "Kirguistán", capital: "Biskek" },
        { country: "Laos", capital: "Vientián" },
        { country: "Letonia", capital: "Riga" },
        { country: "Líbano", capital: "Beirut" },
        { country: "Lesoto", capital: "Maseru" },
        { country: "Liberia", capital: "Monrovia" },
        { country: "Libia", capital: "Trípoli" },
        { country: "Liechtenstein", capital: "Vaduz" },
        { country: "Lituania", capital: "Vilna" },
        { country: "Luxemburgo", capital: "Luxemburgo" },
        { country: "Madagascar", capital: "Antananarivo" },
        { country: "Malaui", capital: "Lilongüe" },
        { country: "Malasia", capital: "Kuala Lumpur" },
        { country: "Maldivas", capital: "Malé" },
        { country: "Malí", capital: "Bamako" },
        { country: "Malta", capital: "La Valeta" },
        { country: "Islas Marshall", capital: "Majuro" },
        { country: "Mauritania", capital: "Nuakchot" },
        { country: "Mauricio", capital: "Port Louis" },
        { country: "México", capital: "Ciudad de México" },
        { country: "Micronesia", capital: "Palikir" },
        { country: "Moldavia", capital: "Chisináu" },
        { country: "Mónaco", capital: "Mónaco" },
        { country: "Mongolia", capital: "Ulán Bator" },
        { country: "Montenegro", capital: "Podgorica" },
        { country: "Marruecos", capital: "Rabat" },
        { country: "Mozambique", capital: "Maputo" },
        { country: "Birmania", capital: "Naipyidó" },
        { country: "Namibia", capital: "Windhoek" },
        { country: "Nauru", capital: "Yaren" },
        { country: "Nepal", capital: "Katmandú" },
        { country: "Países Bajos", capital: "Ámsterdam" },
        { country: "Nueva Zelanda", capital: "Wellington" },
        { country: "Nicaragua", capital: "Managua" },
        { country: "Níger", capital: "Niamey" },
        { country: "Nigeria", capital: "Abuya" },
        { country: "Macedonia del Norte", capital: "Skopie" },
        { country: "Noruega", capital: "Oslo" },
        { country: "Omán", capital: "Mascate" },
        { country: "Pakistán", capital: "Islamabad" },
        { country: "Palaos", capital: "Ngerulmud" },
        { country: "Panamá", capital: "Ciudad de Panamá" },
        { country: "Papúa Nueva Guinea", capital: "Port Moresby" },
        { country: "Paraguay", capital: "Asunción" },
        { country: "Perú", capital: "Lima" },
        { country: "Filipinas", capital: "Manila" },
        { country: "Polonia", capital: "Varsovia" },
        { country: "Portugal", capital: "Lisboa" },
        { country: "Catar", capital: "Doha" },
        { country: "Rumania", capital: "Bucarest" },
        { country: "Rusia", capital: "Moscú" },
        { country: "Ruanda", capital: "Kigali" },
        { country: "San Cristóbal y Nieves", capital: "Basseterre" },
        { country: "San Vicente y las Granadinas", capital: "Kingstown" },
        { country: "Santa Lucía", capital: "Castries" },
        { country: "Samoa", capital: "Apia" },
        { country: "San Marino", capital: "San Marino" },
        { country: "Santo Tomé y Príncipe", capital: "Santo Tomé" },
        { country: "Senegal", capital: "Dakar" },
        { country: "Serbia", capital: "Belgrado" },
        { country: "Seychelles", capital: "Victoria" },
        { country: "Sierra Leona", capital: "Freetown" },
        { country: "Singapur", capital: "Singapur" },
        { country: "Eslovaquia", capital: "Bratislava" },
        { country: "Eslovenia", capital: "Liubliana" },
        { country: "Islas Salomón", capital: "Honiara" },
        { country: "Somalia", capital: "Mogadiscio" },
        { country: "Sudáfrica", capital: "Pretoria" },
        { country: "Sudán del Sur", capital: "Yuba" },
        { country: "Sudán", capital: "Jartum" },
        { country: "Sri Lanka", capital: "Sri Jayawardenapura" },
        { country: "Palestina", capital: "Jerusalén Este" },
        { country: "Estados Unidos", capital: "Washington, D.C." },
        { country: "Uruguay", capital: "Montevideo" },
        { country: "Uzbekistán", capital: "Taskent" },
        { country: "Vanuatu", capital: "Port Vila" },
        { country: "Ciudad del Vaticano", capital: "Ciudad del Vaticano" },
        { country: "Venezuela", capital: "Caracas" },
        { country: "Vietnam", capital: "Hanói" },
        { country: "Yemen", capital: "Saná" },
        { country: "Zambia", capital: "Lusaka" },
        { country: "Zimbabue", capital: "Harare" }
      ];
      function generateQuestion() {
        const rnd = Math.floor(Math.random() * countries.length);
        const item = countries[rnd];
        correctAnswer = item.capital;
        questionText = `¿Cuál es la capital de ${item.country}?`;
        updateQuestionPanel();
        createAnswerObjects(selectedNumAnswers, false);
        beepPlayed = false;
        currentQuestionStartTime = performance.now();
      }

      function createScoreDisplay() {
        const canvas = document.createElement('canvas');
        canvas.width = 256 * resolutionFactor;
        canvas.height = 128 * resolutionFactor;
        scoreMesh = createCanvasPlane(canvas, canvas.getContext('2d'), 0.6, 0.3);
        scoreMesh.position.set(0, -0.2, -0.82);
        scene.add(scoreMesh);
      }
      function updateScoreDisplay() {
        if (!scoreMesh) return;
        const { canvas, ctx, texture } = scoreMesh.userData;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(`Aciertos: ${correctCount} | Fallos: ${wrongCount}`, canvas.width / 2, canvas.height / 2);
        texture.needsUpdate = true;
      }
      function startCountdown() {
        gameStartTime = performance.now();
        const canvas = document.createElement('canvas');
        canvas.width = 256 * resolutionFactor;
        canvas.height = 128 * resolutionFactor;
        countdownMesh = createCanvasPlane(canvas, canvas.getContext('2d'), 0.6, 0.3);
        countdownMesh.position.set(0, 0.50, -0.82);
        scene.add(countdownMesh);
      }
      function updateCountdown() {
        if (!countdownMesh) return;
        const { canvas, ctx, texture } = countdownMesh.userData;
        const elapsed = (performance.now() - gameStartTime) / 1000;
        const remaining = Math.max(0, gameDuration - elapsed);
        const seconds = Math.floor(remaining);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = (remaining <= 10) ? "red" : "#FFFFFF";
        ctx.font = 'Bold ' + (64 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(seconds < 10 ? "00:0" + seconds : "00:" + seconds, canvas.width / 2, canvas.height / 2);
        texture.needsUpdate = true;
        if (remaining <= -10 && !beepPlayed) {
          const beepSound = document.getElementById('beepSound');
          beepSound.currentTime = 0;
          beepSound.play().catch(e => {});
          beepPlayed = true;
        }
        return remaining;
      }

      function createSparksEffect(pos) {
        if (!sparkTexture) {
          const size = 128;
          const c = document.createElement('canvas');
          c.width = size; c.height = size;
          const ctx = c.getContext('2d');
          const grd = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
          grd.addColorStop(0, 'rgba(255,255,255,1)');
          grd.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, size, size);
          sparkTexture = new THREE.CanvasTexture(c);
          sparkTexture.minFilter = THREE.LinearFilter;
        }
        const count = 100;
        const positions = new Float32Array(count * 3);
        const velocities = [];
        for (let i = 0; i < count; i++) {
          positions[i*3+0] = pos.x;
          positions[i*3+1] = pos.y;
          positions[i*3+2] = pos.z;
          velocities.push(new THREE.Vector3(
            (Math.random()-0.5)*0.5,
            (Math.random()-0.5)*0.5,
            (Math.random()-0.5)*0.5
          ));
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const mat = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.02,
          map: sparkTexture,
          transparent: true,
          opacity: 1.0,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          alphaTest: 0.5,
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);
        sparksSystems.push({
          points,
          velocities,
          startTime: performance.now(),
          lastUpdate: performance.now()
        });
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }
      function render(timestamp, xrFrame) {
        renderer.render(scene, camera);
        answers.forEach((mesh, index) => {
          if (mesh.userData.baseY === undefined) {
            mesh.userData.baseY = mesh.position.y;
          }
          mesh.position.y = mesh.userData.baseY + 0.02 * Math.sin(timestamp * 0.005 + index);
        });
        if (gameReady && !countdownStarted) {
          startCountdown();
          const timerSound = document.getElementById('timerSound');
          timerSound.loop = false;
          timerSound.play().catch(e => {});
          countdownStarted = true;
        }
        if (!gameOver) {
          const remaining = updateCountdown();
          updateScoreDisplay();
          if (remaining <= 0) {
            endGame();
          }
        }
        const session = renderer.xr.getSession();
        let interactionPoints = [];
        if (session && xrFrame) {
          for (const inputSource of session.inputSources) {
            if (inputSource.hand) {
              const indexTip = inputSource.hand.get('index-finger-tip');
              if (indexTip) {
                const jointPose = xrFrame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
                if (jointPose) {
                  interactionPoints.push(new THREE.Vector3(
                    jointPose.transform.position.x,
                    jointPose.transform.position.y,
                    jointPose.transform.position.z
                  ));
                }
              }
            }
          }
        }
        if (interactionPoints.length === 0) {
          let camPos = new THREE.Vector3();
          camera.getWorldPosition(camPos);
          interactionPoints.push(camPos);
        }
        if (!gameOver) {
          for (let panel of answers) {
            const panelPos = new THREE.Vector3();
            panel.getWorldPosition(panelPos);
            for (const pt of interactionPoints) {
              const dist = panelPos.distanceTo(pt);
              if (dist < collisionThreshold && !hasCollided) {
                hasCollided = true;
                if (panel.userData.answer === correctAnswer) {
                  let responseTime = performance.now() - currentQuestionStartTime;
                  correctResponseTimes.push(responseTime);
                  correctCount++;
                  playSound('successSound');
                  createSparksEffect(panel.position);
                  if (questionMesh) questionMesh.visible = false;
                  answers.forEach(a => a.visible = false);
                  setTimeout(() => {
                    if (!gameOver) {
                      generateQuestion();
                      if (questionMesh) questionMesh.visible = true;
                      answers.forEach(a => a.visible = true);
                    }
                    hasCollided = false;
                  }, 1000);
                } else {
                  wrongCount++;
                  playSound('errorSound');
                  answers.forEach(a => a.material.color.set(0xff0000));
                  setTimeout(() => {
                    answers.forEach(a => a.material.color.set(0xffffff));
                    hasCollided = false;
                  }, 500);
                }
                break;
              }
            }
          }
        } else {
          // En estado final, detectar colisiones con el botón Reiniciar y Salir
          if (restartButtonMesh || exitButtonMesh) {
            let finalButtons = [];
            if (restartButtonMesh) finalButtons.push(restartButtonMesh);
            if (exitButtonMesh) finalButtons.push(exitButtonMesh);

            for (const btn of finalButtons) {
              if (!btn.visible) continue;
              const btnPos = new THREE.Vector3();
              btn.getWorldPosition(btnPos);
              for (const pt of interactionPoints) {
                if (btnPos.distanceTo(pt) < collisionThreshold && !hasCollided) {
                  hasCollided = true;

                  // REINICIAR
                  if (btn === restartButtonMesh) {
                    playSound('successSound');
                    createSparksEffect(btn.position);
                    btn.visible = false;
                    setTimeout(() => {
                      restartGame();
                      hasCollided = false;
                    }, 1000);

                  // SALIR => recarga la página
                  } else if (btn === exitButtonMesh) {
                    playSound('successSound');
                    createSparksEffect(btn.position);
                    btn.visible = false;
                    setTimeout(() => {
                      location.reload();
                      hasCollided = false;
                    }, 2000);
                  }
                  return;
                }
              }
            }
          }
        }
        const now = performance.now();
        for (let i = sparksSystems.length - 1; i >= 0; i--) {
          const sys = sparksSystems[i];
          const dt = (now - sys.lastUpdate) / 1000;
          sys.lastUpdate = now;
          const posArray = sys.points.geometry.attributes.position.array;
          for (let j = 0; j < sys.velocities.length; j++) {
            posArray[j * 3 + 0] += sys.velocities[j].x * dt;
            posArray[j * 3 + 1] += sys.velocities[j].y * dt;
            posArray[j * 3 + 2] += sys.velocities[j].z * dt;
          }
          sys.points.geometry.attributes.position.needsUpdate = true;
          let life = now - sys.startTime;
          if (life > 1700) {
            let fadeTime = life - 1700;
            let fadeFactor = Math.max(0, 1 - (fadeTime / 300));
            sys.points.material.opacity = fadeFactor;
          }
          if (life > 2000) {
            scene.remove(sys.points);
            sparksSystems.splice(i, 1);
          }
        }
      }

      function restartGame() {
        if (leaderboardMesh) scene.remove(leaderboardMesh);
        if (restartButtonMesh) scene.remove(restartButtonMesh);
        if (exitButtonMesh) scene.remove(exitButtonMesh);
        leaderboardMesh = null;
        restartButtonMesh = null;
        exitButtonMesh = null;

        leaderboardResults = [];
        playerPosition = null;
        if (questionMesh) {
          scene.remove(questionMesh);
          questionMesh = null;
        }
        correctCount = 0;
        wrongCount = 0;
        gameOver = false;
        answers.forEach(a => scene.remove(a));
        answers = [];
        createAnswerObjects(selectedNumAnswers, true);
        generateQuestion();
        countdownStarted = false;
        gameReady = true;
        createScoreDisplay();
        const timerSound = document.getElementById('timerSound');
        timerSound.currentTime = 0;
        timerSound.loop = false;
        timerSound.play().catch(e => {});
      }

      // Se crea el leaderboard y también un botón "Salir" a la derecha
      function createLeaderboardMesh() {
        if (leaderboardMesh) scene.remove(leaderboardMesh);
        if (restartButtonMesh) scene.remove(restartButtonMesh);
        if (exitButtonMesh) scene.remove(exitButtonMesh);

        leaderboardMesh = null;
        restartButtonMesh = null;
        exitButtonMesh = null;

        const dummyCanvas = document.createElement('canvas');
        dummyCanvas.width = 512;
        dummyCanvas.height = 512;
        const ctx = dummyCanvas.getContext('2d');
        const lbTexture = new THREE.CanvasTexture(dummyCanvas);
        lbTexture.minFilter = THREE.LinearFilter;
        lbTexture.magFilter = THREE.LinearFilter;
        const planeWidth = 1.2;
        const planeHeight = 1.0;
        const lbGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const lbMaterial = new THREE.MeshBasicMaterial({ map: lbTexture, transparent: true });
        leaderboardMesh = new THREE.Mesh(lbGeometry, lbMaterial);
        leaderboardMesh.userData = { canvas: dummyCanvas, ctx, texture: lbTexture, planeWidth, planeHeight };
        leaderboardMesh.position.set(0, 0, -1.2);
        scene.add(leaderboardMesh);

        // Botón "Reiniciar" a la izquierda
        restartButtonMesh = createButton("Reiniciar");
        restartButtonMesh.position.set(-planeWidth / 2 - 0.1, 0, -1.1);
        scene.add(restartButtonMesh);

        // NUEVO: Botón "Salir" a la derecha
        exitButtonMesh = createButton("Salir");
        exitButtonMesh.position.set(planeWidth / 2 + 0.1, 0, -1.1);
        scene.add(exitButtonMesh);
      }

      // Dibujar la tabla de clasificación
      function drawLeaderboardSegment() {
        if (!leaderboardMesh) return;
        const { canvas, ctx, texture, planeWidth } = leaderboardMesh.userData;
        const headerHeight = 40 * resolutionFactor;
        const rowHeight = 30 * resolutionFactor;
        const total = leaderboardResults.length;
        const displayCount = Math.min(10, total);
        let playerIndex;
        if (playerPosition !== null) {
          playerIndex = playerPosition - 1;
        } else {
          playerIndex = Math.floor(displayCount / 2);
        }
        let startIndex = Math.max(0, playerIndex - Math.floor(displayCount / 2));
        if (startIndex + displayCount > total) {
          startIndex = total - displayCount;
          if (startIndex < 0) startIndex = 0;
        }
        const displayResults = leaderboardResults.slice(startIndex, startIndex + displayCount);
        const canvasWidth = 512 * resolutionFactor;
        const canvasHeight = headerHeight + rowHeight * displayCount;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (28 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(`Tabla de Clasificación`, canvasWidth / 2, headerHeight / 2);
        // Cabecera
        const xPosPos   = 0.10 * canvasWidth;
        const xPosName  = 0.40 * canvasWidth;
        const xPosScore = 0.75 * canvasWidth;
        let yPos = headerHeight;
        ctx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "left";
        ctx.fillText("Pos", xPosPos, yPos);
        ctx.fillText("Nombre", xPosName, yPos);
        ctx.fillText("Puntos", xPosScore, yPos);
        yPos += rowHeight;
        for (let i = 0; i < displayResults.length; i++) {
          const data = displayResults[i];
          const globalRank = startIndex + i + 1;
          if (playerPosition !== null && globalRank === playerPosition) {
            ctx.fillStyle = "green";
            ctx.fillRect(0, yPos - rowHeight * 0.6, canvasWidth, rowHeight);
            ctx.fillStyle = "#FFFFFF";
          } else {
            ctx.fillStyle = "#FFFFFF";
          }
          ctx.fillText(String(globalRank), xPosPos, yPos);
          ctx.fillText(data.name, xPosName, yPos);
          ctx.fillText(String(data.score), xPosScore, yPos);
          yPos += rowHeight;
        }
        if (playerPosition !== null) {
          ctx.textAlign = "center";
          ctx.fillText(`Tu posición: ${playerPosition}`, canvasWidth / 2, yPos + rowHeight);
        }
        texture.needsUpdate = true;
        const planeHeightNew = planeWidth * (canvasHeight / canvasWidth);
        leaderboardMesh.geometry.dispose();
        leaderboardMesh.geometry = new THREE.PlaneGeometry(planeWidth, planeHeightNew);
        leaderboardMesh.position.set(0, 0, -1.2);
      }

      async function endGame() {
        gameOver = true;
        if (questionMesh) scene.remove(questionMesh);
        if (countdownMesh) scene.remove(countdownMesh);
        if (scoreMesh) scene.remove(scoreMesh);
        answers.forEach(panel => scene.remove(panel));
        let avgTime = 0;
        if (correctResponseTimes.length > 0) {
          let sumTimes = correctResponseTimes.reduce((acc, t) => acc + t, 0);
          avgTime = sumTimes / correctResponseTimes.length / 1000;
        }
        const rawScore = (correctCount - wrongCount) - avgTime;
        const finalScore = parseFloat(rawScore.toFixed(3));
        const collectionName = `Capleaderboard_${selectedNumAnswers}`;
        let docsFound = await getDocs(
          query(
            collection(db, collectionName),
            where("name", "==", playerName),
            limit(1)
          )
        );
        if(!docsFound.empty) {
          const docToUpdate = docsFound.docs[0];
          await updateDoc(doc(db, collectionName, docToUpdate.id), {
            score: finalScore,
            timestamp: serverTimestamp()
          });
        } else {
          await addDoc(collection(db, collectionName), {
            name: playerName,
            score: finalScore,
            timestamp: serverTimestamp()
          });
        }
        let qLeaderboard = query(
          collection(db, collectionName),
          orderBy("score", "desc")
        );
        let querySnapshot;
        try {
          querySnapshot = await getDocs(qLeaderboard);
        } catch(err) {
          console.error("Error consultando leaderboard:", err);
          return;
        }
        leaderboardResults = [];
        let idx = 0;
        querySnapshot.forEach(docSnap=>{
          let data = docSnap.data();
          leaderboardResults.push({ ...data, _index: idx });
          idx++;
        });
        // Determinar la posición del jugador
        let pIndex = leaderboardResults.findIndex(r => r.name === playerName && r.score === finalScore);
        playerPosition = (pIndex >= 0) ? (pIndex + 1) : null;
        createLeaderboardMesh();
        drawLeaderboardSegment();
      }

      /***** 4) Funciones para el modo HTML (no AR) *****/
      function initHTML() {
        const gameContainer = document.createElement('div');
        gameContainer.id = 'gameContainer';
        document.body.appendChild(gameContainer);

        const questionDiv = document.createElement('div');
        questionDiv.id = 'question';
        questionDiv.style.fontSize = '32px';
        gameContainer.appendChild(questionDiv);

        const answersDiv = document.createElement('div');
        answersDiv.id = 'answers';
        answersDiv.style.display = 'flex';
        answersDiv.style.flexWrap = 'wrap';
        answersDiv.style.gap = '10px';
        gameContainer.appendChild(answersDiv);

        const countdownDiv = document.createElement('div');
        countdownDiv.id = 'countdown';
        countdownDiv.style.fontSize = '24px';
        gameContainer.appendChild(countdownDiv);

        const scoreDiv = document.createElement('div');
        scoreDiv.id = 'score';
        scoreDiv.style.fontSize = '24px';
        gameContainer.appendChild(scoreDiv);

        const leaderboardDiv = document.createElement('div');
        leaderboardDiv.id = 'leaderboard';
        leaderboardDiv.style.maxWidth = "auto";
        leaderboardDiv.style.maxHeight = "120px";
        leaderboardDiv.style.overflowY = "auto";
        leaderboardDiv.style.backgroundColor = "#fff";
        leaderboardDiv.style.color = "#000";
        leaderboardDiv.style.fontSize = "12px";
        leaderboardDiv.style.border = "1px solid #000";
        leaderboardDiv.style.borderRadius = "6px";
        leaderboardDiv.style.padding = "4px";
        gameContainer.appendChild(leaderboardDiv);

        startHTMLGame();
      }

      let htmlCountdownInterval;
      function startHTMLGame() {
        correctCount = 0;
        wrongCount = 0;
        gameOver = false;
        correctResponseTimes = [];
        gameStartTime = performance.now();
        startHTMLCountdown();
        const timerSound = document.getElementById('timerSound');
        timerSound.loop = false;
        timerSound.play().catch(e => {});
        nextHTMLQuestion();
        updateHTMLScore();
      }

      function nextHTMLQuestion() {
        generateHTMLQuestion();
        updateHTMLQuestion();
        createHTMLAnswerButtons();
      }

      function generateHTMLQuestion() {
        const rnd = Math.floor(Math.random() * countries.length);
        const item = countries[rnd];
        correctAnswer = item.capital;
        questionText = `¿Cuál es la capital de ${item.country}?`;
        currentQuestionStartTime = performance.now();
      }

      function updateHTMLQuestion() {
        const questionDiv = document.getElementById('question');
        questionDiv.innerText = questionText;
      }

      function createHTMLAnswerButtons() {
        const answersDiv = document.getElementById('answers');
        answersDiv.innerHTML = '';
        const wrongSet = new Set();
        while(wrongSet.size < (selectedNumAnswers - 1)) {
          const rnd = Math.floor(Math.random() * countries.length);
          const cand = countries[rnd].capital;
          if(cand !== correctAnswer) {
            wrongSet.add(cand);
          }
        }
        const array = [correctAnswer, ...wrongSet];
        array.sort(() => Math.random() - 0.5);
        array.forEach(ans => {
          const btn = document.createElement('button');
          btn.innerText = ans;
          btn.style.fontSize = '24px';
          btn.style.padding = '10px 20px';
          btn.onclick = () => handleHTMLAnswer(ans, btn);
          answersDiv.appendChild(btn);
        });
      }

      function handleHTMLAnswer(selected, btn) {
        if(gameOver) return;
        if(selected === correctAnswer) {
          btn.style.backgroundColor = "lightgreen";
          let responseTime = performance.now() - currentQuestionStartTime;
          correctResponseTimes.push(responseTime);
          correctCount++;
          updateHTMLScore();
          const successSound = document.getElementById('successSound');
          const clone = successSound.cloneNode();
          clone.play().catch(e => {});
          setTimeout(() => {
            btn.style.backgroundColor = "";
            nextHTMLQuestion();
          }, 1000);
        } else {
          btn.style.backgroundColor = "red";
          wrongCount++;
          updateHTMLScore();
          const errorSound = document.getElementById('errorSound');
          const clone = errorSound.cloneNode();
          clone.play().catch(e => {});
          setTimeout(() => {
            btn.style.backgroundColor = "";
          }, 500);
        }
      }

      function startHTMLCountdown() {
        if(htmlCountdownInterval) clearInterval(htmlCountdownInterval);
        htmlCountdownInterval = setInterval(()=>{
          const elapsed = (performance.now() - gameStartTime)/1000;
          const remaining = Math.max(0, gameDuration - elapsed);
          document.getElementById('countdown').innerText = `Tiempo: ${Math.floor(remaining)}`;
          if(remaining <= 0) {
            clearInterval(htmlCountdownInterval);
            endHTMLGame();
          }
        }, 1000);
      }

      function updateHTMLScore() {
        document.getElementById('score').innerText = `Aciertos: ${correctCount} | Fallos: ${wrongCount}`;
      }

      async function endHTMLGame() {
        gameOver = true;
        let avgTime = 0;
        if(correctResponseTimes.length > 0) {
          let sum = correctResponseTimes.reduce((acc, t) => acc + t, 0);
          avgTime = sum / correctResponseTimes.length / 1000;
        }
        const rawScore = (correctCount - wrongCount) - avgTime;
        const finalScore = parseFloat(rawScore.toFixed(3));
        const collectionName = `Capleaderboard_${selectedNumAnswers}`;
        let docsFound = await getDocs(
          query(
            collection(db, collectionName),
            where("name", "==", playerName),
            limit(1)
          )
        );
        if(!docsFound.empty) {
          const docToUpdate = docsFound.docs[0];
          await updateDoc(doc(db, collectionName, docToUpdate.id), {
            score: finalScore,
            timestamp: serverTimestamp()
          });
        } else {
          await addDoc(collection(db, collectionName), {
            name: playerName,
            score: finalScore,
            timestamp: serverTimestamp()
          });
        }
        let qLeaderboard = query(
          collection(db, collectionName),
          orderBy("score", "desc")
        );
        let querySnapshot;
        try {
          querySnapshot = await getDocs(qLeaderboard);
        } catch(err) {
          console.error("Error consultando leaderboard:", err);
          return;
        }
        let results = [];
        let idx = 0;
        querySnapshot.forEach(docSnap=>{
          let data = docSnap.data();
          results.push({ ...data, _index: idx });
          idx++;
        });
        displayHTMLLeaderboard(results, finalScore);
        const gameContainer = document.getElementById('gameContainer');
        const restartBtn = document.createElement('button');
        restartBtn.innerText = "Reiniciar";
        restartBtn.style.fontSize = '24px';
        restartBtn.style.padding = '10px 20px';
        restartBtn.onclick = ()=>{
          restartBtn.remove();
          document.getElementById('leaderboard').innerHTML = '';
          document.getElementById('question').innerText = '';
          document.getElementById('answers').innerHTML = '';
          startHTMLGame();
        };
        gameContainer.appendChild(restartBtn);
      }

      function displayHTMLLeaderboard(leaderboardResults, finalScore) {
        const leaderboardDiv = document.getElementById('leaderboard');
        leaderboardDiv.innerHTML = '';
        const table = document.createElement('table');
        table.style.width = '100px';
        const headerRow = document.createElement('tr');
        ['Pos', 'Nombre', 'Puntos'].forEach(header => {
          const th = document.createElement('th');
          th.innerText = header;
          headerRow.appendChild(th);
        });
        table.appendChild(headerRow);
        leaderboardResults.forEach((data, index) => {
          const row = document.createElement('tr');
          if (data.name === playerName && data.score === finalScore) {
            row.style.backgroundColor = 'green';
            row.style.color = '#fff';
          }
          const posCell = document.createElement('td');
          posCell.innerText = index + 1;
          const nameCell = document.createElement('td');
          nameCell.innerText = data.name;
          const scoreCell = document.createElement('td');
          scoreCell.innerText = data.score;
          row.appendChild(posCell);
          row.appendChild(nameCell);
          row.appendChild(scoreCell);
          table.appendChild(row);
        });
        leaderboardDiv.appendChild(table);
      }

      /***** 5) Inicio: Comprobación de soporte AR y elección de modo *****/
      window.addEventListener('DOMContentLoaded', async () => {
        let arSupported = false;
        if(navigator.xr) {
          try {
            arSupported = await navigator.xr.isSessionSupported('immersive-ar');
          } catch(e) {
            arSupported = false;
          }
        }
        if(arSupported) {
          init();
          animate();
        } else {
          const overlay = document.createElement('div');
          overlay.id = 'overlay';
          overlay.innerHTML = `
            <img src="ARCapitals2.jpeg" alt="ARCapitals" style="margin-bottom:20px; margin-top:0px;">
            <a href="https://www.youtube.com/@rafgim" target="_blank">© By Rafael Gimeno</a>
            <div class="respuestas-container">
              <label for="numAnswers">Respuestas:</label>
              <select id="numAnswers">
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
              </select>
            </div>
            <div id="leaderboardPreview"></div>
            <input type="text" id="playerName" placeholder="Ingresa tu nombre" style="padding:10px; font-size:16px; margin-bottom:20px;" maxlength="10">
          `;
          document.body.appendChild(overlay);
          document.getElementById('numAnswers').addEventListener('change', () => {
            const num = parseInt(document.getElementById('numAnswers').value) || 4;
            updateLeaderboardPreview(num);
          });
          updateLeaderboardPreview(4);
          const startBtn = document.createElement('button');
          startBtn.innerText = "AR no compatible, Iniciar Juego HTML";
          startBtn.style.fontSize = "16px";
          startBtn.style.padding = "10px 20px";
          startBtn.style.marginTop = "20px";
          startBtn.onclick = () => {
            selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
            playerName = document.getElementById('playerName').value || "Jugador";
            overlay.remove();
            initHTML();
          };
          overlay.appendChild(startBtn);
        }
        window.addEventListener('touchstart', function unlockAudio() {
          const audios = [document.getElementById('successSound'), document.getElementById('errorSound')];
          audios.forEach(audioEl => {
            audioEl.play().then(() => {
              audioEl.pause();
              audioEl.currentTime = 0;
            }).catch(e => {});
          });
        }, { once: true });
      });
    </script>
  </body>
</html>
